# ✅ useEffect × socket.on/off 重複防止の本質まとめ

## 問題
- React 18（開発モード）では useEffect が **2回実行される**
- `socket.on()` を無名関数で登録すると **リスナーが重複し、ログが2回表示される**

## 原因
- `useEffect` が再実行されても、前のリスナーが解除されないと**積み重なる**
- `socket.off()` に **同じ関数参照** を渡さないと解除できない

## 解決策
```jsx
useEffect(() => {
  const handleLog = (data) => setLogs(prev => [...prev, data]);

  socket.on("log", handleLog);

  return () => {
    socket.off("log", handleLog); // ✅ クリーンアップで重複防止
  };
}, []);
```

---

## 🔄 クリーンアップ関数とは？

```js
return () => { ... }
```

- `useEffect` の戻り値として定義する関数
- 副作用（socket.on など）を **片付ける処理を書く場所**

---

## 🕒 実行タイミング（超重要）

| タイミング | 説明 |
|------------|------|
| ✅ useEffect が再実行される前 | 同じ依存（[]）でも React 18 開発モードでは **確認のために実行 → 即クリーンアップ → 再実行** |
| ✅ コンポーネントがアンマウントされるとき | ページ遷移や条件付き描画で DOM から消える直前 |

---

## ポイント
- `socket.on/off` に渡す関数は **同じ参照** にすること（匿名関数はNG）
- `return () => { socket.off(...) }` を書くことで **リスナーが重複しない**
- 本番環境では `useEffect` は1回だけ実行されるため問題は出ない

