# 関数コンポーネント

## 関数コンポーネントとクラスコンポーネントの違い
クラスコンポーネントは状態を保持できるが、関数コンポーネントは保持できない。そのためフック、(ステートフック)を用いる。
変数では値を保持できないため、必ずステートフックを用いる。

## ステートフックuseState
```
import React, {useState} from "react"
const [count, setCount] = useState(0);
```

## 副作用フックuseEffect
doChange()とかでステートの更新を行い、useEffect()で計算処理を行うなどして使う。useEffectは複数作れる。
処理ごとに関数を分けて記述することができる。  
### 実行タイミング
1. 初回レンダリング後  
   - コンポーネントが初めてマウント(DOMに追加)されたとき。
3. 依存関係の値が変更されたとき  
   -  ```useEffect(()=>{}, [依存関係])```のように、第二引数に渡された依存関係の中の値が更新されたときに実行される。
   第二引数を指定しないと再レンダリング後に実行される。
```
import React, {useEffect} from "react"
useEffect(()=>{
  処理を記述
}, [依存関係])
```

### warning: maximum update depth exceeded
useEffetはレンダリングされるたびに実行されるため、useEffectの中でJSXをステートに入れるなどの再レンダリングを起こす処理を書くと、無限ループしてしまう。  
**理由：JSXはコード上では同じでも、毎回異なるオブジェクトを生成するため、Reactの内部では異なる値として認識され再レンダリングが起こる**

```
======無限ループするコード==========
useEffect(() => {
  let res = <div>Content</div>
  setMsg(res) //更新する値がJSX
})

======無限ループしないコード==========
useEffect(()=>{
    let total = 0;
    for(let i=0; i<val; i++){
      total++;
    }
    setMsg("total: " + total + "."); //更新する値が文字列
})
```
そのため、依存関係を記述して、その依存関係のステートが更新されていないときはuseEffectを実行しないようにする必要がある。  
逆にJSXを値としてステートを更新する処理がない場合は以下のようなプロセスで無限ループを回避している。  
1. useEffectが実行される
2. 内部でステートの更新(文字列など)
3. 結果的に再レンダリング
4. もう一回useEffectが実行される
5. ただ、ステートが先ほどのものから変化していないと判断し、再レンダリングのトリガーにはならない

## 独自フック
利点：再利用性の向上、UIとロジックの分離

## ステートフックの永続化
### ステートはリロードで消える
ステートは現在のページにおいてのみ値が保持されるため、リロードなどすると消える。そのため値をずっと保持し続けるには「ローカルストレージ」を用いる。

### ローカルストレージ
ローカルストレージはwebブラウザのJavascriptに搭載されている機能でローカル環境に値を保存しておくもの。  
指定のキーから値を取得する  
```変数 = window.localStrage.getItem(キー)```  
値を指定のキーで保存する  
```window.localStrage.setItem(キー, 値)```  

